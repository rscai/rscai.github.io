= API Testing by Spring MVC Test Framework
:layout: post
:page-category: spring-boot
:page-tags: [spring-boot, spring, spring-mvc, test, api]
:source-highlighter: rouge
:icons: font

== What is API Testing

API is the interface between **service** and **consumer**. **Consumer** depends on **API** than **service**, it care behaviors of API more than service's. Consumer could work well if behaviors of API satisfy.
[plantuml]
....
@startuml
node "Server" {
     interface API
     [service] - API
}
node "Client" {
     [consumer]
}

API - [consumer]
@enduml
....

As pricinple of verifying what it depends on, it is sense to verify API's behaviours than service's implementation.

[plantuml]
....
@startuml
node "Server" {
     interface API
     [service] - API
}
node "Test Machine" {
     [test case]
}

API - [test case]
@enduml
....

== Spring MVC Test Framework

The core of Spring MVC is `DispatcherServlet`. `DispatcherServlet` is an implementation of `HttpServlet`, which intercept all incoming request and dispatch to **controller**. As it is a **Servlet**, `DispatcherServlet` is running inside a **Servlet Container**. Servlet container handles HTTP communication, listen on port, receive request package and convert to `HttpServletRequest` object, convert `HttpServletResponse` object which return by controller (actually it is rendered by **View**) and send to client application. 
[plantuml]
....
@startuml
node "Server" {
     frame "ServletContainer" {
           interface HTTP
           [dispatcherServlet] - HTTP
           [dispatcherServlet] --> [controller]: dispatch request
     }
}
node "Client" {
     [application]
}

HTTP <- [application]: request/response
@enduml
....
[quote]
____
The Spring MVC Test framework provides first class support for testing Spring MVC code with a fluent API that you can use with JUnit, TestNG, or any other testing framework. It is built on the Servlet API mock objects from the spring-test module and, hence, does not use a running Servlet container. It uses the DispatcherServlet to provide full Spring MVC runtime behavior and provides support for loading actual Spring configuration with the TestContext framework in addition to a standalone mode, in which you can manually instantiate controllers and test them one at a time.
____

[plantuml]
....
@startuml
node "Test Machine" {
     [test case] --> [MockMvc]: perform get/post/put/delete
     [MockMvc] -> [dispatcherServlet]: doService(request: HttpServletRequest, response: HttpServletResponse)
     [dispatcherServlet] --> [controller]: dispatch request
@enduml
....

Spring Boot scan and assemble MockMvc, controllers, DispatcherServlet and other beans. MockMvc is invoking `doService` of DispatcherServlet for mocking HTTP request processing directly. Test case is able to perform request on DispatcherServelt through MockMvc.

== Configure Spring MVC Test

Auto-Configuration is the remakrable feature offered by Spring Boot. Unexpectedly, Spring MVC Test framework offers auto-configuration of MockMvc. Annotation `@AutoConfigureMockMvc` enable MockMvc auto configuration.

.ProductImageTest.java
[source, java]
----
@ActiveProfiles({"test"})
@RunWith(SpringRunner.class) // <1>
@SpringBootTest(classes = CatalogApplication.class) // <2>
@AutoConfigureMockMvc // <3>
public class ProductImageTest {

  private static final String ENDPOINT = "/productImages";
  @Autowired
  private MockMvc mvc; // <4>
  @Autowired
  private ObjectMapper objectMapper; 
  @Autowired
  private ProductImageRepository imageRepository; 
  ...
----
<1> run JUnit test case by `SpringRunner` which handle Spring context initialization, includes annotations scanning and bean assembling.
<2> set root context for test case.
<3> enable MockMvc auto-configuration.
<4> inject MockMvc bean.

== Performing Requests

It can perofrma requests that use any HTTP method through MockMvc. For example:

[source, java]
----
mockMvc.perform(post("/productImages")
                  .contentType(MediaType.APPLICATION_JSON)
                  .content(jsonContent));
----

MockMvc offers methods to specify each part of HTTP request.

A well formed HTTP request consists of three parts:

[source, bnf]
....
HTTP-message   = start-line
                                  *( header-field CRLF )
                                  CRLF
                                  [ message-body ]

start-line     = request-line / status-line

request-line   = method SP request-target SP HTTP-version CRLF
....

HTTP protocol defines nine methods, but only seven of them are defined for application:

* GET
* POST
* PUT
* DELETE
* PATCH
* OPTIONS
* HEAD

It offers builder methods in `MockMvcRequestBuilders` to contruct corresponding `MockMvcRequestBuilder`. Application developer can specify each part of HTTP request through `MockMvcRequestBuilder`.

Specify headers:

[source, java]
....
mockMvc.perform(post("/productImages")
                                  .accept(MediaType.APPLICATION_JSON)
                                  .contentType(MediaType.APPLICATION_JSON)
                                  .header("Custom-Header", "some value"));
....

Specify request body:

[source, java]
....
mockMvc.perform(post("/productImages")
                                  .content(jsonContent));
....

== Verify Responses

MockMvc wrapper response as `ResultActions`. Application developer can verify each part of response through `ResultActions`.

HTTP response message consists of three parts:

[source, bnf]
....
HTTP-message   = start-line
                                  *( header-field CRLF )
                                  CRLF
                                  [ message-body ]

start-line     = request-line / status-line

status-line = HTTP-version SP status-code SP reason-phrase CRLF
....

It offers tools to extract information from response, and verify them.

Verify status code:

[source, java]
....
mockMvc.perform(post("/productImages")
                                  .content(jsonContent))
                              .andExpect(status().isCreated());
....

Verify response body:

[source, java]
....
mockMvc.perform(post("/productImages")
                                  .content(jsonContent))
                              .andExpect(jsonPath("$.title", is(title));
....

== Reference

* https://docs.spring.io/spring/docs/current/spring-framework-reference/testing.html#spring-mvc-test-framework[Spring MVC Test Framework]
